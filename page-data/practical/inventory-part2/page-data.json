{"componentChunkName":"component---src-pages-practical-inventory-part-2-index-mdx","path":"/practical/inventory-part2/","result":{"pageContext":{"isCreatedByStatefulCreatePages":true,"frontmatter":{"title":"Inventory Micro App - Part 2"},"relativePagePath":"/practical/inventory-part2/index.mdx","titleType":"page","MdxNode":{"id":"b00e2d6b-6b43-567a-9a29-9de5a2cba0a2","children":[],"parent":"dc52dfea-e647-5932-b0dd-3865bd498282","internal":{"content":"---\ntitle: Inventory Micro App - Part 2\n---\n\n<PageDescription>\n\nExtending Part 1 of your 3 tier app to include Continuous Delivery to Test, Securing the User Interface and integrating the service to a cloud database\n\n</PageDescription>\n\n<AnchorLinks>\n  <AnchorLink to=\"#using-cd-to-deliver-to-test\">Using CD to deliver to Test</AnchorLink>\n  <AnchorLink to=\"#enabling-application-security-with-app-id\">Securing the User Interface</AnchorLink>\n  <AnchorLink to=\"#add-a-cloudant-integration-to-your-backend-service\">Integrating with NoSQL Database</AnchorLink>\n</AnchorLinks>\n\n## Guide\n\nThis Micro App guidance continues to build upon the microserivces that were built in the [Inventory Micro App Part 1](/practical/inventory-part1) guide. Make sure you have complete [Part 1](/practical/inventory-part1) or deployed the working [Inventory Solution](/practical/inventory-part1#solution-links)\n\nPart 2 of the Inventory MicoApp guide is a follow on from Part 1 and will concentrate on building out the following areas:\n\n- Delivering the solution images into the `test` namespace/project using CD techniques and ArgoCD\n- Enabling application security with **App ID**\n- Adding **Cloudant** database and populating it with data\n\n### Using CD to deliver to Test\n\nArgoCD is a tool that provides Continuous Delivery for projects and applications. If you haven't already, be sure to read\nthrough the [Continuous Delivery with ArgoCD Guide](/guides/continuous-delivery).\n\nFor this exercise, we are going to use ArgoCD to push the Inventory app from `dev` to `test` (and possibly `staging` as well).\nIf you have already completed the Inventory MicroApp then it can be used for the ArgoCD process (although perhaps with\nsome minor pipeline updates).\n\nIf you haven't completed the exercise you can start from the solution repositories to perform the ArgoCD steps.\n\n#### Deploy the Inventory App solution\n\nTo make sure you are starting from a common solution foundation, use the solution templates create your Inventory App\n\n##### Inventory Services\n\n- Create a new project from the [Inventory Management Service solution template](https://github.com/ibm-garage-cloud/inventory-management-svc-solution/generate)\nnamed `inventory-management-svc-{initials}`\n\n- Clone the repository to your local machine\n\n- Log into the cluster from the command-line then [register the pipeline](/getting-started/deploy-app#register-the-app-in-a-devops-pipeline)\n    ```\n    igc pipeline -n dev-{your initials}\n    ```\n\n   - replacing `{your initials}` with your actual initials\n\n- Run `igc credentials` to get the credentials for the Jenkins instance.\n\n- Open the [pipeline to see it running](/getting-started/deploy-app#view-your-application-pipeline)\n\n##### Inventory BFF\n\n- Create a new project from the [Inventory Management BFF solution template](https://github.com/ibm-garage-cloud/inventory-management-bff-solution/generate)\nnamed `inventory-management-bff-{initials}`\n\n- Clone the repository to your local machine\n\n- Log into the cluster from the command-line then [register the pipeline](/getting-started/deploy-app#register-the-app-in-a-devops-pipeline)\n    ```\n    igc pipeline -n dev-{your initials}\n    ```\n\n   - replacing `{your initials}` with your actual initials\n\n- Run `igc credentials` to get the credentials for the Jenkins instance.\n\n- Open the [pipeline to see it running](/getting-started/deploy-app#view-your-application-pipeline)\n\n- Update the `serviceUrl` value in `charts/template-graphql-typescript/values.yaml` to point to the kubernetes \nservice of the microservice. The value most likely will be `inventory-management-svc-{initials}:80`.\n\n- Commit and push the changes\n    ```bash\n    git add .\n    git commit -m \"Update the serviceUrl\"\n    git push\n    ```\n\n##### Inventory UI\n\n- Create a new project from the [Inventory Management UI solution template](https://github.com/ibm-garage-cloud/inventory-management-ui-solution/generate)\nnamed `inventory-management-ui-{initials}`\n\n- Clone the repository to your local machine\n\n- Log into the cluster from the command-line then [register the pipeline](/getting-started/deploy-app#register-the-app-in-a-devops-pipeline)\n    ```\n    igc pipeline -n dev-{your initials}\n    ```\n\n   - replacing `{your initials}` with your actual initials\n\n- Run `igc credentials` to get the credentials for the Jenkins instance.\n\n- Open the [pipeline to see it running](/getting-started/deploy-app#view-your-application-pipeline)\n\n- Update the `hostApi` value in `charts/template-node-react/values.yaml` to point to the kubernetes \nservice of the BFF. The value most likely will be `inventory-management-bff-{initials}:80`.\n\n- Commit and push the changes\n    ```bash\n    git add .\n    git commit -m \"Update the hostApi\"\n    git push\n    ```\n\n- Verify that the application is running\n\n#### Setup the GitOps repo\n\nArgoCD uses a Git repo to express the desired state of the Kubernetes environment. The basic setup uses one repository to\nrepresent one `project`. Within that repository, each `application` that makes up the project will be described in its own\nfolder. The repository will also contain a branch for each environment/namespace into which we want to deploy the \napplications. Git offers a number of benefits for a development team with GitOps. It has an audit log of change whole releases can be managed from a pull request and git enables changes to be rollback quickly if there is an issue with a new release.\n\n- Create a new repo from the [ArgoCD Starter Kit template](https://github.com/ibm-garage-cloud/template-argocd-test/generate)\n\n- Clone the project to your machine\n\n- Create a branch named `test`\n    ```bash\n    git checkout -b test\n    ```\n  \n- Push the branch to the remote\n    ```bash\n    git push -u origin test\n    ```\n  \n- Create the test namespace with the CLI by running `igc namespace test-{initials}`\n\n#### Register the GitOps repo in ArgoCD\n\nNow that the repository has been created, we need to tell ArgoCD where it is.\n\n- Get the ArgoCD login information from the `igc credentials` cli command\n\n    <InlineNotification>\n        Note: You need to be logged into the cluster on the command-line for the CLI to access the cluster information.\n    </InlineNotification>\n\n- Log into ArgoCD\n\n- Click on the gear icon on the left menu to access the Settings options\n\n    ![ArgoCD config](/images/argocd-config.png)\n\n- Select the `Repositories` option\n\n- Click either the `Connect Repo using HTTPS` or `Connect Repo using SSH` button at the top and provide the information\nfor the GitOps repo you just created.\n\n#### Create a project in ArgoCD (Optional)\n\nIn ArgoCD terms, each deployable component is an `Application` and applications are grouped into `Projects`. Projects are not \nrequired for ArgoCD to be able to deploy applications but it helps to organize applications and provide some restrictions\non what can be done for applications that make up a project.\n\nTo create a project, do the following:\n\n- Log into ArgoCD\n\n- Click on the gear icon on the left menu to access the Settings options\n\n    ![ArgoCD config](/images/argocd-config.png)\n\n- Select the `Projects` option\n\n- Click the `New Project` button at the top of the page.\n\n- Provide the following values then press `Create`:\n\n    - `name` - the name for the project (provide `inventory-management)\n    - `description` - a brief description of the project\n    - `sources` - click `add source` and pick the Git repository from the list that was added previously\n    - `destinations` \n        - Add `https://kubernetes.default.svc` for the cluster url and `test-{initials}` for the namespace\n        - Add `https://kubernetes.default.svc` for the cluster url and `staging-{initials}` for the namespace\n\n    **Note:** Initially, the only cluster that is available is the one in which ArgoCD is - \n    `https://kubernetes.default.svc`. By adding the two destinations we have allowed the project to be deployed\n    to both the `test-{initials}` and `staging-{initials}` namespaces within the current cluster.\n\n#### Configure the GitOps repo for Inventory Management service\n\n- Copy the `app-artifactory` folder and give it a name that matches the Inventory Management service component \n(e.g. `inventory-management-svc-{initials}`)\n\n- Update `inventory-management-svc-{initials}/Chart.yaml` and update the name to match the directory name\n\n- Update `inventory-management-svc-{initials}/requirements.yaml` with the following values:\n\n    - `name` - the name of helm chart/image. This should match the folder name\n    - `version` - the version number of the helm chart\n    - `repository` - the url to the helm repository\n    \n    The url of the Artifactory helm repository can be determines by following the steps described in\n    [Administrator Guide - ArgoCD setup](/admin/argocd-setup/#get-the-helm-repository-location)\n\n- Run `kubectl get configmap/ibmcloud-config -n tools -o yaml` to print the configuration information\nfor the cluster\n\n- In `inventory-management-svc-{initials}/values.yaml` replace `<app-chart-name>` with the directory name. Replace \n`ingressSubdomain` with the value from the previous step. Update `tlsSecretName` with the value from the \nprevious step. The result should look something like the following\n    ```yaml path=inventory-management-svc-{initials}/values.yaml\n    global:\n      ingressSubdomain: sms-test.us-south.containers.appdomain.cloud\n      tlsSecretName: sms-test-cluster\n\n    inventory-management-svc-{initials}:\n      replicaCount: 1\n\n      ingress:\n        enabled: true\n        tlsSecretName: sms-test-cluster\n    ```\n\n- Commit and push the changes\n    ```bash\n    git add .\n    git commit -m \"Adds inventory-management-svc config\"\n    git push\n    ```\n\n#### Add an application in ArgoCD for the Inventory Management service \n\nThe last step in the process is to define the application(s) within ArgoCD that should be managed. This consists of\nconnecting the config within the Git repo to the cluster and namespace.\n\n- Log into ArgoCD\n\n- Click `New Application` and provide the following values:\n\n    - `application name` - `test-inventory-management-svc`\n    - `project` - `inventory-management`\n    - `sync-policy` - `Automatic`\n    - `repository url` - The Git url where the configuration is stored\n    - `revision` - `test`\n    - `path` - `inventory-management-svc-{initials}`\n    - `destination cluster` - The cluster url for the deployment\n    - `destination namespace` - `test-{initials}`\n    - `values file` - `values.yaml`\n\n- Click `Create`\n\n- Click on the newly created application. A graph of kubernetes resources should be shown\nif everything is configured correctly.\n\n#### Make a change in the GitOps repo\n\nIn order to trigger a (re-)deployment we can make an update to a value in the GitOps repo and\nwatch ArgoCD apply the change.\n\n- Open a terminal and navigate to your GitOps repo directory\n\n- Be sure that you are in the `test` branch\n    ```bash\n    git checkout test\n    ```\n\n- Update `inventory-management-svc-{initials}/values.yaml` to increase the replica count\n    ```yaml path=inventory-management-svc-{initials}/values.yaml\n    global:\n      ingressSubdomain: sms-test.us-south.containers.appdomain.cloud\n      tlsSecretName: sms-test-cluster\n\n    inventory-management-svc-{initials}:\n      replicaCount: 3\n\n      ingress:\n        enabled: true\n        tlsSecretName: sms-test-cluster\n    ```\n\n- Commit and push the change\n    ```bash\n    git add .\n    git commit -m \"Increases replica count\"\n    ```\n\n- Log into the ArgoCD UI and look at the state of the application. It should say `Synchronizing`.\nIf you don't want to wait you can manually by pressing the `Synchronize` button.\n\n#### Hook the CI pipeline to the CD pipeline\n\nThe last stage in the CI pipeline updates the version number in the `requirements.yaml` to the version of the helm chart\nthat was just built. Through a couple naming conventions the only thing the pipeline needs in order to interact\nwith the CD process is a kubernetes secret named `gitops-cd-secret` that provides the details needed\nto connect to the git repo to push updates.\n\nThe [IGC CLI](/getting-started/cli) has a command that provides a helper to make the creating of a kubernetes secret\nwith git credentials very easy.\n\n- Log into the cluster on the command-line.\n\n- Change the directory to the root of the ArgoCD Starter Kit repo that was cloned previously.\n\n- Run `igc git-secret gitops-cd-secret -n dev-{initials}` to create the secret. This command will prompt for the username,\npersonal access token, and the branch to put in the secret.\n\n    **What just happened?**\n    \n    - The `git-secret` command creates a secret in a kubernetes namespace containing the url, username, password, and branch information\n    for a git repo. In the command above, we provided `gitops-cd-secret` for the secret name. (If that value is left off the\n    secret name defaults to `{git org}.{git repo}`.) You can verify the secret was created by running: \n    \n    - ```kubectl get secrets/gitops-cd-secret -n dev-{initials} -o yaml```\n\n    **Note:** \n    \n    - For the secret to be available to the CI pipeline, the secret needs to be created in the same namespace\n    where the pipeline is running (e.g. `dev-{initials}`).\n    - The value provided for `branch` is the one the pipeline will use to when committing changes to trigger \n    the CD pipeline. `test` is the recommended value for the branch field.\n\n- Trigger the pipeline for the Inventory Management service to build by making a change\nto the Inventory Management Service code and push the changes to Git.\n\n#### Repeat for BFF and UI components\n\nStarting from [Configure the GitOps repo for Inventory Management service](#Configure-the-gitops-repo-for-inventory-management-service),\nthe steps need to be repeated for each application within the project.\n\n### Securing the solution with **App ID**\n\n#### Inventory Management UI\n\n1. Update the `values.yaml` file in the Inventory Management UI chart to set `ingress.appId.enabled=true` and to \nset the value for the AppId binding secret\n    ```yaml path=/chart/template-java-spring/values.yaml\n    ...\n    appidBinding: \"binding-sms-test-oc-appid\"\n\n    ingress:\n      enabled: true\n      appid:\n        enabled: true\n        # web or app - https://cloud.ibm.com/docs/services/appid?topic=appid-kube-auth\n        requestType: web\n        ...\n    ```\n\n#### AppId redirect url config\n\n- Get the ingress for the service by running `igc ingress -n dev-{initials}`.\n\n- Open the IBM Cloud resource list - `https://cloud.ibm.com/resources`\n\n- Open the AppId instance to the `Manage Authentication` -> `Authentication Settings` view\n\n    ![AppId authentication settings](images/appid-authentication-settings.png)\n\n- Add the redirect url for the application to the web redirect URLs. The redirect url will have\nthe following form:\n\n    `{ingress url}/appid_callback`\n    \n    e.g. `https://inventory-manangement-ui-dev.sms-test-oc-cluster.us-east.containers.appdomain.cloud/appid_callback`\n\n#### Add users to AppId\n\n1. Open the AppId instance to `Cloud Directory` -> `Users`\n\n    ![AppId cloud directory users](images/appid-cloud-directory-users.png)\n\n2. Add users\n\n### Add a Cloudant integration to your backend service\n\n- While logged into the IBM Cloud account use the resource list to find your pre installed Cloudant database instance name after your development cluster.\n\n- Open the database instance dashboard.\n\n- Click on the Service Credentials on the left-hand menu.\n- You will see the credentials for the database.\n\n- Open a terminal window folder/directory called `data`\n    ```bash\n    mkdir data\n    ```\n\n- To help create test JSON data we are going to supply a template to the JSON Generator tool, this helps when creating dummy data for testing. Navigate to the following link [https://www.json-generator.com/](https://www.json-generator.com/)\n\n- Replace the default template with the following template (using cut and paste). This will enable a 100 records of test data to be created to represent a products database. Click on the *Generate* button.\n    ```bash\n    [\n      '{{repeat(1, 50)}}',\n      {\n        id: '{{objectId()}}',\n        manufacturer: '{{company().toUpperCase()}}',\n        name:  '{{lorem(3, \"words\")}}',\n        price: '{{floating(10, 1000, 2, \"0.00\")}}',\n        stock: '{{integer(1, 100)}}'\n      }\n    ]\n    ```\n- Copy the generated contents on the right hand side into a file called `inventory.json` and save it into the same folder. Wrap the array with a docs statement.\n    ```json\n    {\n      \"docs\": <Add Generated array here>\n    }\n    ```\n- Save the documents that will be loaded into Cloudant\n\n- Using a code editor create a shell script called `load.sh` that will load data into the database using a `curl` command. Use the contents from below for the script.\n    ```\n    #!/bin/sh\n    # Cloudant Database Data Load Utility\n\n    # Credentials from IBM Cloud\n    CLOUDANT_USERNAME=\n    CLOUDANT_PASSWORD=\n\n    # name of database\n    DATABASE=inventor-<replace with namespace>\n\n    # input validation\n    if [ -z \"${CLOUDANT_USERNAME}\" ]; then\n        echo \"Please provide your CLOUDANT_USERNAME.\"\n        exit\n    fi\n    if [ -z \"${CLOUDANT_PASSWORD}\" ]; then\n        echo \"Please provide your CLOUDANT_PASSWORD.\"\n        exit\n    fi\n\n    # credentials to post data to cloudant\n    AUTH=\"$(python -c 'import base64; print base64.urlsafe_b64encode(\"'${CLOUDANT_USERNAME}':'${CLOUDANT_PASSWORD}'\")')\"\n    ACURL=\"curl -s --proto '=https' -iv -g -H 'Authorization: Basic ${AUTH}'\"\n    HOST=\"https://${CLOUDANT_USERNAME}.cloudant.com\"\n\n    # Inventory\n    eval ${ACURL} -X DELETE '${HOST}/${DATABASE}'\n    eval ${ACURL} -X PUT '${HOST}/${DATABASE}'\n    eval ${ACURL} -H \"Content-Type:application/json\" -d @inventory.json -vX POST '${HOST}/${DATABASE}/_bulk_docs'\n\n    ```\n\n- Add the `username` and `password` to `CLOUDANT_USERNAME` and `CLOUDANT_PASSWORD variables in the `load.sh` script. You can get the credentals from the Cloudant credentials view in the IBM Cloud console.\n- Add database name `inventor-<replace with namespace>` using the dev namespace/project name you have been using.\n- Save the script, make it executable, and then run it.\n    ```\n    chmod +x ./load.sh\n    ./load.sh\n    ```\n- The data from the `inventory.json` file will then be used to populate the database, to confirm this on the Dashboard click on Manage menu on the left and then Launch button to see the Cloudant dashboard.\n- Click on the Left icon that looks like a Database and you will see the `inventory-<namespace>` database created.\n- Click on the `inventory` database, then click **Table** view.\n- You can see the rows of data\n    ![Database](/images/database.png)\n\n- If you click on a row of data, you will see the raw NoSQL form of the data record.\n- This completes the setup of the database and populating it with data.\n\n### Add a Cloudant integration to your backend service\n\n#### Update the gradle config to include cloudant dependencies\n\n1. Add `build-services.gradle` to the gradle folder\n\n    gradle/build-services.gradle\n    ```\n    dependencies {\n        compile group: 'com.cloudant', name: 'cloudant-client', version: '2.17.0'\n        compile group: 'com.jayway.jsonpath', name: 'json-path', version: '2.4.0'\n        compile group: 'javax.xml.bind', name: 'jaxb-api', version: '2.1'\n        compile group: 'joda-time', name: 'joda-time', version: '2.10.3'\n    }\n    ```\n\n2. Apply build-services.gradle to build.gradle\n\n    build.gradle\n    ```\n    ...\n    apply from:   'gradle/build-services.gradle'\n    ...\n    ```\n\n#### Add configuration values\n\n1. Add CloudantConfig to hold the url, username, password, and databaseName values\n\n    com.ibm.inventory_management.config.CloudantConfig\n    ```java\n    package com.ibm.inventory_management.config;\n\n    import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n\n    @JsonIgnoreProperties(ignoreUnknown = true)\n    public class CloudantConfig {\n        private String url;\n        private String username;\n        private String password;\n        private String databaseName;\n\n        public String getUrl() {\n            return url;\n        }\n\n        public void setUrl(String url) {\n            this.url = url;\n        }\n\n        public CloudantConfig withUrl(String url) {\n            this.setUrl(url);\n\n            return this;\n        }\n\n        public String getUsername() {\n            return username;\n        }\n\n        public void setUsername(String username) {\n            this.username = username;\n        }\n\n        public CloudantConfig withUsername(String username) {\n            this.setUsername(username);\n\n            return this;\n        }\n\n        public String getPassword() {\n            return password;\n        }\n\n        public void setPassword(String password) {\n            this.password = password;\n        }\n\n        public CloudantConfig withPassword(String password) {\n            this.setPassword(password);\n\n            return this;\n        }\n\n        public String getDatabaseName() {\n            return databaseName;\n        }\n\n        public void setDatabaseName(String databaseName) {\n            this.databaseName = databaseName;\n        }\n\n        public CloudantConfig withDatabaseName(String databaseName) {\n            this.setDatabaseName(databaseName);\n\n            return this;\n        }\n\n        public String toString() {\n            return \"[CloudantConfig: url=\" + this.url + \", username=\" + this.username + \", name=\" + this.databaseName + \"]\";\n        }\n    }\n    ```\n\n2. Implement logic to load the configuration from the secret binding or local file\n\n    com.ibm.inventory_management.config.CloudantMapping\n    ```java\n    package com.ibm.inventory_management.config;\n\n    import java.io.Serializable;\n\n    import com.fasterxml.jackson.annotation.JsonProperty;\n\n    public class CloudantMapping implements Serializable {\n        @JsonProperty(value = \"CLOUDANT_CONFIG\")\n        private String cloudantConfig;\n\n        public String getCloudantConfig() {\n            return cloudantConfig;\n        }\n\n        public void setCloudantConfig(String cloudantConfig) {\n            this.cloudantConfig = cloudantConfig;\n        }\n    }\n    ```\n\n    com.ibm.inventory_management.config.CloudantConfigFactory\n    ```java\n    package com.ibm.inventory_management.config;\n\n    import java.io.IOException;\n\n    import com.fasterxml.jackson.databind.ObjectMapper;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.stereotype.Component;\n\n    @Component\n    public class CloudantConfigFactory {\n        @Bean\n        public CloudantConfig buildCloudantConfig() throws IOException {\n            return buildConfigFromBinding(\n                    loadCloudantConfig(),\n                    loadDatabaseName()\n            );\n        }\n\n        protected String loadCloudantConfig() throws IOException {\n            return System.getProperty(\"CLOUDANT_CONFIG\") != null\n                    ? System.getProperty(\"CLOUDANT_CONFIG\")\n                    : loadCloudantConfigFromLocalDev();\n        }\n\n        protected String loadCloudantConfigFromLocalDev() throws IOException {\n            final ObjectMapper mapper = new ObjectMapper();\n\n            final CloudantMapping mappings = mapper.readValue(\n                    this.getClass().getClassLoader().getResourceAsStream(\"mappings.json\"),\n                    CloudantMapping.class\n            );\n\n            return mappings.getCloudantConfig();\n        }\n\n        protected String loadDatabaseName() {\n            return System.getProperty(\"DATABASE_NAME\") != null\n                    ? System.getProperty(\"DATABASE_NAME\")\n                    : \"stock-items\";\n        }\n\n        protected CloudantConfig buildConfigFromBinding(String binding, String databaseName) throws IOException {\n            final ObjectMapper mapper = new ObjectMapper();\n\n            return mapper.readValue(binding, CloudantConfig.class)\n                    .withDatabaseName(databaseName);\n        }\n    }\n    ```\n\n#### Set up local development\n\n1. Log into cloud.ibm.com and open the Cloudant service from the resource list\n\n2. Click on service credentials and expand the listed credentials\n\n3. Copy the json contents from the credentials into `mappings.json` under CLOUDANT_CONFIG\n\n    src/main/resources/mappings.json\n    ```\n    {\n      \"CLOUDANT_CONFIG\": \"{paste json here}\"\n    }\n    ```\n\n#### Implement the service\n\n1. Add a CloudantApi component to create the CloudantClient instance from the configuration\n\n    com.ibm.inventory_management.service.CloudServicesException\n    ```java\n    package com.ibm.inventory_management.service;\n\n    public class CloudServicesException extends Exception {\n        public CloudServicesException() {\n        }\n\n        public CloudServicesException(String message) {\n            super(message);\n        }\n\n        public CloudServicesException(String message, Throwable cause) {\n            super(message, cause);\n        }\n\n        public CloudServicesException(Throwable cause) {\n            super(cause);\n        }\n\n        public CloudServicesException(\n                String message,\n                Throwable cause,\n                boolean enableSuppression,\n                boolean writableStackTrace\n        ) {\n            super(message, cause, enableSuppression, writableStackTrace);\n        }\n    }\n    ```\n\n    com.ibm.inventory_management.service.CloudantApi\n    ```java\n    package com.ibm.inventory_management.service;\n\n    import java.net.MalformedURLException;\n    import java.net.URL;\n\n    import com.cloudant.client.api.ClientBuilder;\n    import com.cloudant.client.api.CloudantClient;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.stereotype.Component;\n\n    import com.ibm.inventory_management.config.CloudantConfig;\n\n    @Component\n    public class CloudantApi {\n        @Bean\n        public CloudantClient buildCloudant(CloudantConfig config) throws CloudServicesException {\n            System.out.println(\"Config: \" + config);\n            URL url = null;\n            try {\n                url = new URL(config.getUrl());\n            } catch (MalformedURLException e) {\n                throw new CloudServicesException(\"Invalid service URL specified\", e);\n            }\n\n            return ClientBuilder\n                    .url(url)\n                    .username(config.getUsername())\n                    .password(config.getPassword())\n                    .build();\n        }\n    }\n    ```\n\n2. Add the service implementation\n\n    com.ibm.inventory_management.service.StockItemService\n    ```java\n    package com.ibm.inventory_management.service;\n\n    import java.io.IOException;\n    import java.util.List;\n    import javax.annotation.PostConstruct;\n\n    import com.cloudant.client.api.CloudantClient;\n    import com.cloudant.client.api.Database;\n    import org.springframework.context.annotation.Primary;\n    import org.springframework.stereotype.Service;\n\n    import com.ibm.inventory_management.config.CloudantConfig;\n    import com.ibm.inventory_management.model.StockItem;\n\n    @Service\n    @Primary\n    public class StockItemService implements StockItemApi {\n        private CloudantConfig config;\n        private CloudantClient client;\n        private Database db = null;\n\n        public StockItemService(CloudantConfig config, CloudantClient client) {\n            this.config = config;\n            this.client = client;\n        }\n\n        @PostConstruct\n        public void init() {\n            db = client.database(config.getDatabaseName(), true);\n        }\n\n        @Override\n        public List<StockItem> listStockItems() throws Exception {\n\n            try {\n                return db.getAllDocsRequestBuilder()\n                        .includeDocs(true)\n                        .build()\n                        .getResponse()\n                        .getDocsAs(StockItem.class);\n\n            } catch (IOException e) {\n                throw new Exception(\"\", e);\n            }\n        }\n    }\n    ```\n\n3. Remove the `@Primary` annotation from the mock service\n\n#### Add the values to the helm chart\n\n1. Update the `cloudantBinding` and `databaseName` values in values.yaml\n\n    **Note:** The cloudantBinding value should match the name of the cloudant binding secret\n\n## Review Application End to End\n\n\n\n## Summary\n\nYou have now completed the Micro App Guide demonstrating the _Inventory_ solution.\n\n\n","type":"Mdx","contentDigest":"b2e05d3272f8c8961fe7870e14e2b442","counter":597,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Inventory Micro App - Part 2"},"exports":{},"rawBody":"---\ntitle: Inventory Micro App - Part 2\n---\n\n<PageDescription>\n\nExtending Part 1 of your 3 tier app to include Continuous Delivery to Test, Securing the User Interface and integrating the service to a cloud database\n\n</PageDescription>\n\n<AnchorLinks>\n  <AnchorLink to=\"#using-cd-to-deliver-to-test\">Using CD to deliver to Test</AnchorLink>\n  <AnchorLink to=\"#enabling-application-security-with-app-id\">Securing the User Interface</AnchorLink>\n  <AnchorLink to=\"#add-a-cloudant-integration-to-your-backend-service\">Integrating with NoSQL Database</AnchorLink>\n</AnchorLinks>\n\n## Guide\n\nThis Micro App guidance continues to build upon the microserivces that were built in the [Inventory Micro App Part 1](/practical/inventory-part1) guide. Make sure you have complete [Part 1](/practical/inventory-part1) or deployed the working [Inventory Solution](/practical/inventory-part1#solution-links)\n\nPart 2 of the Inventory MicoApp guide is a follow on from Part 1 and will concentrate on building out the following areas:\n\n- Delivering the solution images into the `test` namespace/project using CD techniques and ArgoCD\n- Enabling application security with **App ID**\n- Adding **Cloudant** database and populating it with data\n\n### Using CD to deliver to Test\n\nArgoCD is a tool that provides Continuous Delivery for projects and applications. If you haven't already, be sure to read\nthrough the [Continuous Delivery with ArgoCD Guide](/guides/continuous-delivery).\n\nFor this exercise, we are going to use ArgoCD to push the Inventory app from `dev` to `test` (and possibly `staging` as well).\nIf you have already completed the Inventory MicroApp then it can be used for the ArgoCD process (although perhaps with\nsome minor pipeline updates).\n\nIf you haven't completed the exercise you can start from the solution repositories to perform the ArgoCD steps.\n\n#### Deploy the Inventory App solution\n\nTo make sure you are starting from a common solution foundation, use the solution templates create your Inventory App\n\n##### Inventory Services\n\n- Create a new project from the [Inventory Management Service solution template](https://github.com/ibm-garage-cloud/inventory-management-svc-solution/generate)\nnamed `inventory-management-svc-{initials}`\n\n- Clone the repository to your local machine\n\n- Log into the cluster from the command-line then [register the pipeline](/getting-started/deploy-app#register-the-app-in-a-devops-pipeline)\n    ```\n    igc pipeline -n dev-{your initials}\n    ```\n\n   - replacing `{your initials}` with your actual initials\n\n- Run `igc credentials` to get the credentials for the Jenkins instance.\n\n- Open the [pipeline to see it running](/getting-started/deploy-app#view-your-application-pipeline)\n\n##### Inventory BFF\n\n- Create a new project from the [Inventory Management BFF solution template](https://github.com/ibm-garage-cloud/inventory-management-bff-solution/generate)\nnamed `inventory-management-bff-{initials}`\n\n- Clone the repository to your local machine\n\n- Log into the cluster from the command-line then [register the pipeline](/getting-started/deploy-app#register-the-app-in-a-devops-pipeline)\n    ```\n    igc pipeline -n dev-{your initials}\n    ```\n\n   - replacing `{your initials}` with your actual initials\n\n- Run `igc credentials` to get the credentials for the Jenkins instance.\n\n- Open the [pipeline to see it running](/getting-started/deploy-app#view-your-application-pipeline)\n\n- Update the `serviceUrl` value in `charts/template-graphql-typescript/values.yaml` to point to the kubernetes \nservice of the microservice. The value most likely will be `inventory-management-svc-{initials}:80`.\n\n- Commit and push the changes\n    ```bash\n    git add .\n    git commit -m \"Update the serviceUrl\"\n    git push\n    ```\n\n##### Inventory UI\n\n- Create a new project from the [Inventory Management UI solution template](https://github.com/ibm-garage-cloud/inventory-management-ui-solution/generate)\nnamed `inventory-management-ui-{initials}`\n\n- Clone the repository to your local machine\n\n- Log into the cluster from the command-line then [register the pipeline](/getting-started/deploy-app#register-the-app-in-a-devops-pipeline)\n    ```\n    igc pipeline -n dev-{your initials}\n    ```\n\n   - replacing `{your initials}` with your actual initials\n\n- Run `igc credentials` to get the credentials for the Jenkins instance.\n\n- Open the [pipeline to see it running](/getting-started/deploy-app#view-your-application-pipeline)\n\n- Update the `hostApi` value in `charts/template-node-react/values.yaml` to point to the kubernetes \nservice of the BFF. The value most likely will be `inventory-management-bff-{initials}:80`.\n\n- Commit and push the changes\n    ```bash\n    git add .\n    git commit -m \"Update the hostApi\"\n    git push\n    ```\n\n- Verify that the application is running\n\n#### Setup the GitOps repo\n\nArgoCD uses a Git repo to express the desired state of the Kubernetes environment. The basic setup uses one repository to\nrepresent one `project`. Within that repository, each `application` that makes up the project will be described in its own\nfolder. The repository will also contain a branch for each environment/namespace into which we want to deploy the \napplications. Git offers a number of benefits for a development team with GitOps. It has an audit log of change whole releases can be managed from a pull request and git enables changes to be rollback quickly if there is an issue with a new release.\n\n- Create a new repo from the [ArgoCD Starter Kit template](https://github.com/ibm-garage-cloud/template-argocd-test/generate)\n\n- Clone the project to your machine\n\n- Create a branch named `test`\n    ```bash\n    git checkout -b test\n    ```\n  \n- Push the branch to the remote\n    ```bash\n    git push -u origin test\n    ```\n  \n- Create the test namespace with the CLI by running `igc namespace test-{initials}`\n\n#### Register the GitOps repo in ArgoCD\n\nNow that the repository has been created, we need to tell ArgoCD where it is.\n\n- Get the ArgoCD login information from the `igc credentials` cli command\n\n    <InlineNotification>\n        Note: You need to be logged into the cluster on the command-line for the CLI to access the cluster information.\n    </InlineNotification>\n\n- Log into ArgoCD\n\n- Click on the gear icon on the left menu to access the Settings options\n\n    ![ArgoCD config](/images/argocd-config.png)\n\n- Select the `Repositories` option\n\n- Click either the `Connect Repo using HTTPS` or `Connect Repo using SSH` button at the top and provide the information\nfor the GitOps repo you just created.\n\n#### Create a project in ArgoCD (Optional)\n\nIn ArgoCD terms, each deployable component is an `Application` and applications are grouped into `Projects`. Projects are not \nrequired for ArgoCD to be able to deploy applications but it helps to organize applications and provide some restrictions\non what can be done for applications that make up a project.\n\nTo create a project, do the following:\n\n- Log into ArgoCD\n\n- Click on the gear icon on the left menu to access the Settings options\n\n    ![ArgoCD config](/images/argocd-config.png)\n\n- Select the `Projects` option\n\n- Click the `New Project` button at the top of the page.\n\n- Provide the following values then press `Create`:\n\n    - `name` - the name for the project (provide `inventory-management)\n    - `description` - a brief description of the project\n    - `sources` - click `add source` and pick the Git repository from the list that was added previously\n    - `destinations` \n        - Add `https://kubernetes.default.svc` for the cluster url and `test-{initials}` for the namespace\n        - Add `https://kubernetes.default.svc` for the cluster url and `staging-{initials}` for the namespace\n\n    **Note:** Initially, the only cluster that is available is the one in which ArgoCD is - \n    `https://kubernetes.default.svc`. By adding the two destinations we have allowed the project to be deployed\n    to both the `test-{initials}` and `staging-{initials}` namespaces within the current cluster.\n\n#### Configure the GitOps repo for Inventory Management service\n\n- Copy the `app-artifactory` folder and give it a name that matches the Inventory Management service component \n(e.g. `inventory-management-svc-{initials}`)\n\n- Update `inventory-management-svc-{initials}/Chart.yaml` and update the name to match the directory name\n\n- Update `inventory-management-svc-{initials}/requirements.yaml` with the following values:\n\n    - `name` - the name of helm chart/image. This should match the folder name\n    - `version` - the version number of the helm chart\n    - `repository` - the url to the helm repository\n    \n    The url of the Artifactory helm repository can be determines by following the steps described in\n    [Administrator Guide - ArgoCD setup](/admin/argocd-setup/#get-the-helm-repository-location)\n\n- Run `kubectl get configmap/ibmcloud-config -n tools -o yaml` to print the configuration information\nfor the cluster\n\n- In `inventory-management-svc-{initials}/values.yaml` replace `<app-chart-name>` with the directory name. Replace \n`ingressSubdomain` with the value from the previous step. Update `tlsSecretName` with the value from the \nprevious step. The result should look something like the following\n    ```yaml path=inventory-management-svc-{initials}/values.yaml\n    global:\n      ingressSubdomain: sms-test.us-south.containers.appdomain.cloud\n      tlsSecretName: sms-test-cluster\n\n    inventory-management-svc-{initials}:\n      replicaCount: 1\n\n      ingress:\n        enabled: true\n        tlsSecretName: sms-test-cluster\n    ```\n\n- Commit and push the changes\n    ```bash\n    git add .\n    git commit -m \"Adds inventory-management-svc config\"\n    git push\n    ```\n\n#### Add an application in ArgoCD for the Inventory Management service \n\nThe last step in the process is to define the application(s) within ArgoCD that should be managed. This consists of\nconnecting the config within the Git repo to the cluster and namespace.\n\n- Log into ArgoCD\n\n- Click `New Application` and provide the following values:\n\n    - `application name` - `test-inventory-management-svc`\n    - `project` - `inventory-management`\n    - `sync-policy` - `Automatic`\n    - `repository url` - The Git url where the configuration is stored\n    - `revision` - `test`\n    - `path` - `inventory-management-svc-{initials}`\n    - `destination cluster` - The cluster url for the deployment\n    - `destination namespace` - `test-{initials}`\n    - `values file` - `values.yaml`\n\n- Click `Create`\n\n- Click on the newly created application. A graph of kubernetes resources should be shown\nif everything is configured correctly.\n\n#### Make a change in the GitOps repo\n\nIn order to trigger a (re-)deployment we can make an update to a value in the GitOps repo and\nwatch ArgoCD apply the change.\n\n- Open a terminal and navigate to your GitOps repo directory\n\n- Be sure that you are in the `test` branch\n    ```bash\n    git checkout test\n    ```\n\n- Update `inventory-management-svc-{initials}/values.yaml` to increase the replica count\n    ```yaml path=inventory-management-svc-{initials}/values.yaml\n    global:\n      ingressSubdomain: sms-test.us-south.containers.appdomain.cloud\n      tlsSecretName: sms-test-cluster\n\n    inventory-management-svc-{initials}:\n      replicaCount: 3\n\n      ingress:\n        enabled: true\n        tlsSecretName: sms-test-cluster\n    ```\n\n- Commit and push the change\n    ```bash\n    git add .\n    git commit -m \"Increases replica count\"\n    ```\n\n- Log into the ArgoCD UI and look at the state of the application. It should say `Synchronizing`.\nIf you don't want to wait you can manually by pressing the `Synchronize` button.\n\n#### Hook the CI pipeline to the CD pipeline\n\nThe last stage in the CI pipeline updates the version number in the `requirements.yaml` to the version of the helm chart\nthat was just built. Through a couple naming conventions the only thing the pipeline needs in order to interact\nwith the CD process is a kubernetes secret named `gitops-cd-secret` that provides the details needed\nto connect to the git repo to push updates.\n\nThe [IGC CLI](/getting-started/cli) has a command that provides a helper to make the creating of a kubernetes secret\nwith git credentials very easy.\n\n- Log into the cluster on the command-line.\n\n- Change the directory to the root of the ArgoCD Starter Kit repo that was cloned previously.\n\n- Run `igc git-secret gitops-cd-secret -n dev-{initials}` to create the secret. This command will prompt for the username,\npersonal access token, and the branch to put in the secret.\n\n    **What just happened?**\n    \n    - The `git-secret` command creates a secret in a kubernetes namespace containing the url, username, password, and branch information\n    for a git repo. In the command above, we provided `gitops-cd-secret` for the secret name. (If that value is left off the\n    secret name defaults to `{git org}.{git repo}`.) You can verify the secret was created by running: \n    \n    - ```kubectl get secrets/gitops-cd-secret -n dev-{initials} -o yaml```\n\n    **Note:** \n    \n    - For the secret to be available to the CI pipeline, the secret needs to be created in the same namespace\n    where the pipeline is running (e.g. `dev-{initials}`).\n    - The value provided for `branch` is the one the pipeline will use to when committing changes to trigger \n    the CD pipeline. `test` is the recommended value for the branch field.\n\n- Trigger the pipeline for the Inventory Management service to build by making a change\nto the Inventory Management Service code and push the changes to Git.\n\n#### Repeat for BFF and UI components\n\nStarting from [Configure the GitOps repo for Inventory Management service](#Configure-the-gitops-repo-for-inventory-management-service),\nthe steps need to be repeated for each application within the project.\n\n### Securing the solution with **App ID**\n\n#### Inventory Management UI\n\n1. Update the `values.yaml` file in the Inventory Management UI chart to set `ingress.appId.enabled=true` and to \nset the value for the AppId binding secret\n    ```yaml path=/chart/template-java-spring/values.yaml\n    ...\n    appidBinding: \"binding-sms-test-oc-appid\"\n\n    ingress:\n      enabled: true\n      appid:\n        enabled: true\n        # web or app - https://cloud.ibm.com/docs/services/appid?topic=appid-kube-auth\n        requestType: web\n        ...\n    ```\n\n#### AppId redirect url config\n\n- Get the ingress for the service by running `igc ingress -n dev-{initials}`.\n\n- Open the IBM Cloud resource list - `https://cloud.ibm.com/resources`\n\n- Open the AppId instance to the `Manage Authentication` -> `Authentication Settings` view\n\n    ![AppId authentication settings](images/appid-authentication-settings.png)\n\n- Add the redirect url for the application to the web redirect URLs. The redirect url will have\nthe following form:\n\n    `{ingress url}/appid_callback`\n    \n    e.g. `https://inventory-manangement-ui-dev.sms-test-oc-cluster.us-east.containers.appdomain.cloud/appid_callback`\n\n#### Add users to AppId\n\n1. Open the AppId instance to `Cloud Directory` -> `Users`\n\n    ![AppId cloud directory users](images/appid-cloud-directory-users.png)\n\n2. Add users\n\n### Add a Cloudant integration to your backend service\n\n- While logged into the IBM Cloud account use the resource list to find your pre installed Cloudant database instance name after your development cluster.\n\n- Open the database instance dashboard.\n\n- Click on the Service Credentials on the left-hand menu.\n- You will see the credentials for the database.\n\n- Open a terminal window folder/directory called `data`\n    ```bash\n    mkdir data\n    ```\n\n- To help create test JSON data we are going to supply a template to the JSON Generator tool, this helps when creating dummy data for testing. Navigate to the following link [https://www.json-generator.com/](https://www.json-generator.com/)\n\n- Replace the default template with the following template (using cut and paste). This will enable a 100 records of test data to be created to represent a products database. Click on the *Generate* button.\n    ```bash\n    [\n      '{{repeat(1, 50)}}',\n      {\n        id: '{{objectId()}}',\n        manufacturer: '{{company().toUpperCase()}}',\n        name:  '{{lorem(3, \"words\")}}',\n        price: '{{floating(10, 1000, 2, \"0.00\")}}',\n        stock: '{{integer(1, 100)}}'\n      }\n    ]\n    ```\n- Copy the generated contents on the right hand side into a file called `inventory.json` and save it into the same folder. Wrap the array with a docs statement.\n    ```json\n    {\n      \"docs\": <Add Generated array here>\n    }\n    ```\n- Save the documents that will be loaded into Cloudant\n\n- Using a code editor create a shell script called `load.sh` that will load data into the database using a `curl` command. Use the contents from below for the script.\n    ```\n    #!/bin/sh\n    # Cloudant Database Data Load Utility\n\n    # Credentials from IBM Cloud\n    CLOUDANT_USERNAME=\n    CLOUDANT_PASSWORD=\n\n    # name of database\n    DATABASE=inventor-<replace with namespace>\n\n    # input validation\n    if [ -z \"${CLOUDANT_USERNAME}\" ]; then\n        echo \"Please provide your CLOUDANT_USERNAME.\"\n        exit\n    fi\n    if [ -z \"${CLOUDANT_PASSWORD}\" ]; then\n        echo \"Please provide your CLOUDANT_PASSWORD.\"\n        exit\n    fi\n\n    # credentials to post data to cloudant\n    AUTH=\"$(python -c 'import base64; print base64.urlsafe_b64encode(\"'${CLOUDANT_USERNAME}':'${CLOUDANT_PASSWORD}'\")')\"\n    ACURL=\"curl -s --proto '=https' -iv -g -H 'Authorization: Basic ${AUTH}'\"\n    HOST=\"https://${CLOUDANT_USERNAME}.cloudant.com\"\n\n    # Inventory\n    eval ${ACURL} -X DELETE '${HOST}/${DATABASE}'\n    eval ${ACURL} -X PUT '${HOST}/${DATABASE}'\n    eval ${ACURL} -H \"Content-Type:application/json\" -d @inventory.json -vX POST '${HOST}/${DATABASE}/_bulk_docs'\n\n    ```\n\n- Add the `username` and `password` to `CLOUDANT_USERNAME` and `CLOUDANT_PASSWORD variables in the `load.sh` script. You can get the credentals from the Cloudant credentials view in the IBM Cloud console.\n- Add database name `inventor-<replace with namespace>` using the dev namespace/project name you have been using.\n- Save the script, make it executable, and then run it.\n    ```\n    chmod +x ./load.sh\n    ./load.sh\n    ```\n- The data from the `inventory.json` file will then be used to populate the database, to confirm this on the Dashboard click on Manage menu on the left and then Launch button to see the Cloudant dashboard.\n- Click on the Left icon that looks like a Database and you will see the `inventory-<namespace>` database created.\n- Click on the `inventory` database, then click **Table** view.\n- You can see the rows of data\n    ![Database](/images/database.png)\n\n- If you click on a row of data, you will see the raw NoSQL form of the data record.\n- This completes the setup of the database and populating it with data.\n\n### Add a Cloudant integration to your backend service\n\n#### Update the gradle config to include cloudant dependencies\n\n1. Add `build-services.gradle` to the gradle folder\n\n    gradle/build-services.gradle\n    ```\n    dependencies {\n        compile group: 'com.cloudant', name: 'cloudant-client', version: '2.17.0'\n        compile group: 'com.jayway.jsonpath', name: 'json-path', version: '2.4.0'\n        compile group: 'javax.xml.bind', name: 'jaxb-api', version: '2.1'\n        compile group: 'joda-time', name: 'joda-time', version: '2.10.3'\n    }\n    ```\n\n2. Apply build-services.gradle to build.gradle\n\n    build.gradle\n    ```\n    ...\n    apply from:   'gradle/build-services.gradle'\n    ...\n    ```\n\n#### Add configuration values\n\n1. Add CloudantConfig to hold the url, username, password, and databaseName values\n\n    com.ibm.inventory_management.config.CloudantConfig\n    ```java\n    package com.ibm.inventory_management.config;\n\n    import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n\n    @JsonIgnoreProperties(ignoreUnknown = true)\n    public class CloudantConfig {\n        private String url;\n        private String username;\n        private String password;\n        private String databaseName;\n\n        public String getUrl() {\n            return url;\n        }\n\n        public void setUrl(String url) {\n            this.url = url;\n        }\n\n        public CloudantConfig withUrl(String url) {\n            this.setUrl(url);\n\n            return this;\n        }\n\n        public String getUsername() {\n            return username;\n        }\n\n        public void setUsername(String username) {\n            this.username = username;\n        }\n\n        public CloudantConfig withUsername(String username) {\n            this.setUsername(username);\n\n            return this;\n        }\n\n        public String getPassword() {\n            return password;\n        }\n\n        public void setPassword(String password) {\n            this.password = password;\n        }\n\n        public CloudantConfig withPassword(String password) {\n            this.setPassword(password);\n\n            return this;\n        }\n\n        public String getDatabaseName() {\n            return databaseName;\n        }\n\n        public void setDatabaseName(String databaseName) {\n            this.databaseName = databaseName;\n        }\n\n        public CloudantConfig withDatabaseName(String databaseName) {\n            this.setDatabaseName(databaseName);\n\n            return this;\n        }\n\n        public String toString() {\n            return \"[CloudantConfig: url=\" + this.url + \", username=\" + this.username + \", name=\" + this.databaseName + \"]\";\n        }\n    }\n    ```\n\n2. Implement logic to load the configuration from the secret binding or local file\n\n    com.ibm.inventory_management.config.CloudantMapping\n    ```java\n    package com.ibm.inventory_management.config;\n\n    import java.io.Serializable;\n\n    import com.fasterxml.jackson.annotation.JsonProperty;\n\n    public class CloudantMapping implements Serializable {\n        @JsonProperty(value = \"CLOUDANT_CONFIG\")\n        private String cloudantConfig;\n\n        public String getCloudantConfig() {\n            return cloudantConfig;\n        }\n\n        public void setCloudantConfig(String cloudantConfig) {\n            this.cloudantConfig = cloudantConfig;\n        }\n    }\n    ```\n\n    com.ibm.inventory_management.config.CloudantConfigFactory\n    ```java\n    package com.ibm.inventory_management.config;\n\n    import java.io.IOException;\n\n    import com.fasterxml.jackson.databind.ObjectMapper;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.stereotype.Component;\n\n    @Component\n    public class CloudantConfigFactory {\n        @Bean\n        public CloudantConfig buildCloudantConfig() throws IOException {\n            return buildConfigFromBinding(\n                    loadCloudantConfig(),\n                    loadDatabaseName()\n            );\n        }\n\n        protected String loadCloudantConfig() throws IOException {\n            return System.getProperty(\"CLOUDANT_CONFIG\") != null\n                    ? System.getProperty(\"CLOUDANT_CONFIG\")\n                    : loadCloudantConfigFromLocalDev();\n        }\n\n        protected String loadCloudantConfigFromLocalDev() throws IOException {\n            final ObjectMapper mapper = new ObjectMapper();\n\n            final CloudantMapping mappings = mapper.readValue(\n                    this.getClass().getClassLoader().getResourceAsStream(\"mappings.json\"),\n                    CloudantMapping.class\n            );\n\n            return mappings.getCloudantConfig();\n        }\n\n        protected String loadDatabaseName() {\n            return System.getProperty(\"DATABASE_NAME\") != null\n                    ? System.getProperty(\"DATABASE_NAME\")\n                    : \"stock-items\";\n        }\n\n        protected CloudantConfig buildConfigFromBinding(String binding, String databaseName) throws IOException {\n            final ObjectMapper mapper = new ObjectMapper();\n\n            return mapper.readValue(binding, CloudantConfig.class)\n                    .withDatabaseName(databaseName);\n        }\n    }\n    ```\n\n#### Set up local development\n\n1. Log into cloud.ibm.com and open the Cloudant service from the resource list\n\n2. Click on service credentials and expand the listed credentials\n\n3. Copy the json contents from the credentials into `mappings.json` under CLOUDANT_CONFIG\n\n    src/main/resources/mappings.json\n    ```\n    {\n      \"CLOUDANT_CONFIG\": \"{paste json here}\"\n    }\n    ```\n\n#### Implement the service\n\n1. Add a CloudantApi component to create the CloudantClient instance from the configuration\n\n    com.ibm.inventory_management.service.CloudServicesException\n    ```java\n    package com.ibm.inventory_management.service;\n\n    public class CloudServicesException extends Exception {\n        public CloudServicesException() {\n        }\n\n        public CloudServicesException(String message) {\n            super(message);\n        }\n\n        public CloudServicesException(String message, Throwable cause) {\n            super(message, cause);\n        }\n\n        public CloudServicesException(Throwable cause) {\n            super(cause);\n        }\n\n        public CloudServicesException(\n                String message,\n                Throwable cause,\n                boolean enableSuppression,\n                boolean writableStackTrace\n        ) {\n            super(message, cause, enableSuppression, writableStackTrace);\n        }\n    }\n    ```\n\n    com.ibm.inventory_management.service.CloudantApi\n    ```java\n    package com.ibm.inventory_management.service;\n\n    import java.net.MalformedURLException;\n    import java.net.URL;\n\n    import com.cloudant.client.api.ClientBuilder;\n    import com.cloudant.client.api.CloudantClient;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.stereotype.Component;\n\n    import com.ibm.inventory_management.config.CloudantConfig;\n\n    @Component\n    public class CloudantApi {\n        @Bean\n        public CloudantClient buildCloudant(CloudantConfig config) throws CloudServicesException {\n            System.out.println(\"Config: \" + config);\n            URL url = null;\n            try {\n                url = new URL(config.getUrl());\n            } catch (MalformedURLException e) {\n                throw new CloudServicesException(\"Invalid service URL specified\", e);\n            }\n\n            return ClientBuilder\n                    .url(url)\n                    .username(config.getUsername())\n                    .password(config.getPassword())\n                    .build();\n        }\n    }\n    ```\n\n2. Add the service implementation\n\n    com.ibm.inventory_management.service.StockItemService\n    ```java\n    package com.ibm.inventory_management.service;\n\n    import java.io.IOException;\n    import java.util.List;\n    import javax.annotation.PostConstruct;\n\n    import com.cloudant.client.api.CloudantClient;\n    import com.cloudant.client.api.Database;\n    import org.springframework.context.annotation.Primary;\n    import org.springframework.stereotype.Service;\n\n    import com.ibm.inventory_management.config.CloudantConfig;\n    import com.ibm.inventory_management.model.StockItem;\n\n    @Service\n    @Primary\n    public class StockItemService implements StockItemApi {\n        private CloudantConfig config;\n        private CloudantClient client;\n        private Database db = null;\n\n        public StockItemService(CloudantConfig config, CloudantClient client) {\n            this.config = config;\n            this.client = client;\n        }\n\n        @PostConstruct\n        public void init() {\n            db = client.database(config.getDatabaseName(), true);\n        }\n\n        @Override\n        public List<StockItem> listStockItems() throws Exception {\n\n            try {\n                return db.getAllDocsRequestBuilder()\n                        .includeDocs(true)\n                        .build()\n                        .getResponse()\n                        .getDocsAs(StockItem.class);\n\n            } catch (IOException e) {\n                throw new Exception(\"\", e);\n            }\n        }\n    }\n    ```\n\n3. Remove the `@Primary` annotation from the mock service\n\n#### Add the values to the helm chart\n\n1. Update the `cloudantBinding` and `databaseName` values in values.yaml\n\n    **Note:** The cloudantBinding value should match the name of the cloudant binding secret\n\n## Review Application End to End\n\n\n\n## Summary\n\nYou have now completed the Micro App Guide demonstrating the _Inventory_ solution.\n\n\n","fileAbsolutePath":"/Users/mjperrins/projects/cat/guide/src/pages/practical/inventory-part2/index.mdx"}}}}